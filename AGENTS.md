- Never check YAML files under `charts/` for correctness - they are components of Helm charts, so will always be invalid YAML.
- Except when debugging or testing something, never make changes directly to the cluster (e.g. with `jsonnet <path> | kubectl apply -f`). Always make a change to the Infrastructure-as-Code definitions, then prompt me to review and push it.
- **CRITICAL:** NEVER run `argocd app sync` or any other ArgoCD commands that modify application state. ArgoCD's API is READ-ONLY for Claude. All changes must go through GitOps (commit to git, let ArgoCD sync automatically or wait for Jack to manually sync). This includes syncing, refreshing, or any other write operations on ArgoCD applications.
- You have access to `kubectl` and `argocd` tools to read state/logs while debugging.

## Repository Structure

### ArgoCD App-of-Apps Pattern

The cluster uses ArgoCD's "app-of-apps" pattern for GitOps deployment:

- **Root Application:** `app-of-apps` (managed by ArgoCD)
  - Source: `https://github.com/scubbo/homelab-configuration`
  - Path: `app-of-apps/`
  - Directory mode with `jsonnet: {}` and `recurse: true`
  - This means ALL `.jsonnet` files in `app-of-apps/` (including subdirectories) are automatically processed

**To add a new application:**
1. Create `app-of-apps/<app-name>.jsonnet` using the patterns from `app-of-apps/app-definitions.libsonnet`
2. ArgoCD will automatically detect and deploy it (no manual registration needed!)
3. Common patterns:
   - `helmApplication()` - Deploy a Helm chart from a remote repository
   - `localApplication()` - Deploy from `/charts/<name>` in this repo
   - `helmRemotePlusLocalApplication()` - Combine remote Helm chart with local resources

**Current applications visible in cluster:**
```bash
kubectl get applications -n argocd
```

### Application Definition Patterns

From `app-of-apps/app-definitions.libsonnet`:

- **helmApplication:** Remote Helm chart only
- **localApplication:** Local chart from `/charts/<name>`
- **kustomizeApplication:** Kustomize-based deployment
- **helmRemotePlusLocalApplication:** Combine remote Helm chart with local manifests (e.g., cert-manager uses this for ClusterIssuers)

All applications default to:
- Server: `https://epsilon:6443`
- Automated sync with prune enabled
- Namespace auto-creation

### Secrets Management (Current State)

**Current approach:** Manual Kubernetes Secrets
- Secrets created with `kubectl create secret`
- Apps reference via `secretKeyRef`
- Kyverno policies inject secrets into pods (see `manifests/gluetun/kyverno-gluetun-inject.yaml`)

**Future plan:** Vault + External Secrets Operator
- Vault is installed at `https://vault.avril`
- See `docs/todo/vault-to-k8s-secrets.md` for migration plan
- Not yet implemented

Examples of current manual secrets:
- `cloudflare-api-key-secret` (cert-manager, namespace: security)
- `gluetun-protonvpn` (VPN credentials, namespace: vpn)
- `immich-database-app` (PostgreSQL, auto-generated by CloudNative-PG)
- `nzbget-creds` (arr-stack)

### Network & DNS

- **Internal TLD:** `.avril` (named after Avril Lavigne, because Everything Is So Complicated)
- **External domain:** `.scubbo.org` (managed via Cloudflare)
- **Ingress Controller:** Traefik (all Ingresses use `ingressClassName: traefik`)
- **Cluster endpoint:** `https://epsilon:6443`
- **Storage servers:** Dynamically-created PVCs via `freenas-iscsi-csi` and `freenas-nfs-csi` Storage Classes (installed separately). As a backup, also NFS at `rassigma.avril` and `rasnu2.avril`

### Key Operators/Controllers

- **cert-manager:** TLS certificate automation (Let's Encrypt + Cloudflare DNS01)
- **Kyverno:** Policy engine (currently used for Gluetun VPN sidecar injection)
- **CloudNative-PG:** PostgreSQL operator
- **Prometheus Stack:** Monitoring (Prometheus, Grafana, AlertManager)
- **Blackbox Exporter:** HTTP/TCP probing for uptime monitoring
- **Vault:** Secret management (installed but not yet integrated with apps)
- **Authentik:** Identity provider for SSO (OIDC) - accessible at `https://auth.avril`

### Documentation

- `/docs/` - General documentation
- `/docs/todo/` - Detailed TODO documents for complex future work
- `/TODO.md` - Simple checklist of pending tasks
- Individual chart READMEs under `/charts/<name>/README.md`
- If you add a new tool, library, installation, or technique, you should draft a blog post about it in `~/Code/blogcontent`
